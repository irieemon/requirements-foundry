---
phase: 10.1-upload-client-direct
plan: 01
type: execute
---

<objective>
Migrate file uploads to use Vercel Blob's client-side direct upload pattern, bypassing the 4.5MB serverless function body limit.

Purpose: Enable uploads of files larger than 4.5MB (e.g., 12MB PDFs) which currently fail with 413 Content Too Large.
Output: Working upload flow that handles files up to 50MB via client-to-Blob direct upload.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Problem:** Vercel serverless functions have a hard 4.5MB body size limit that cannot be configured. Uploads >4.5MB fail with 413 error.

**Solution:** Client-side direct upload to Vercel Blob, then process the blob URL in the API route.

**Current architecture:**
- Browser → POST /api/uploads (FormData with file) → Vercel Blob → DB
- Fails when file > 4.5MB (hits Vercel infrastructure limit before reaching code)

**Target architecture:**
- Browser → PUT to Vercel Blob (signed URL) → returns blob URL
- Browser → POST /api/uploads (blob URL, metadata) → Process from Blob → DB
- No body size limit (Vercel Blob accepts up to 500MB)

**Key files:**
@app/api/uploads/route.ts
@components/uploads/multi-file-upload.tsx
@lib/storage/index.ts

**Vercel Blob client upload docs:**
- Use `upload()` from `@vercel/blob/client` for client-side uploads
- Requires a server endpoint that returns `handleUploadUrl` from `handleUpload()`
- Client gets signed URL, uploads directly to Blob, receives blob URL
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload URL endpoint</name>
  <files>app/api/uploads/get-upload-url/route.ts</files>
  <action>
Create a new API route that generates signed upload URLs for client-side Blob uploads.

Use `handleUpload` from `@vercel/blob` which:
1. Validates the request (file type, size limits)
2. Returns a signed URL for direct client upload
3. Can include metadata (projectId) in the blob pathname

Pattern:
```typescript
import { handleUpload, type HandleUploadBody } from '@vercel/blob';

export async function POST(request: Request): Promise<Response> {
  const body = await request.json() as HandleUploadBody;

  return handleUpload({
    body,
    request,
    onBeforeGenerateToken: async (pathname, clientPayload) => {
      // Validate projectId exists
      // Return allowed content types and max size
      return {
        allowedContentTypes: ['application/pdf', 'application/vnd.openxmlformats-officedocument.*', ...],
        maximumSizeInBytes: 50 * 1024 * 1024, // 50MB
        tokenPayload: JSON.stringify({ projectId: clientPayload?.projectId }),
      };
    },
    onUploadCompleted: async ({ blob, tokenPayload }) => {
      // Optional: Log upload completion
      console.log('Upload completed:', blob.pathname);
    },
  });
}
```

Important: This endpoint returns the upload URL, NOT the file contents. No body size limit applies.
  </action>
  <verify>curl -X POST /api/uploads/get-upload-url -d '{"type":"blob.generate-client-token","payload":{"pathname":"test.pdf","clientPayload":{"projectId":"test"}}}' returns JSON with clientToken</verify>
  <done>Endpoint exists, returns valid signed URLs for client uploads</done>
</task>

<task type="auto">
  <name>Task 2: Update multi-file-upload component for client-side upload</name>
  <files>components/uploads/multi-file-upload.tsx</files>
  <action>
Refactor the upload flow to:
1. Use `upload()` from `@vercel/blob/client` to upload directly to Blob
2. Then call existing `/api/uploads` with blob URL instead of file

Install if needed: `npm install @vercel/blob` (should already be installed based on existing code)

New flow:
```typescript
import { upload } from '@vercel/blob/client';

const handleUpload = async () => {
  for (const { file } of files) {
    // Step 1: Upload to Blob directly (no 4.5MB limit)
    const blob = await upload(file.name, file, {
      access: 'public',
      handleUploadUrl: '/api/uploads/get-upload-url',
      clientPayload: JSON.stringify({ projectId }),
    });

    // Step 2: Process the uploaded blob (extraction, DB record)
    const response = await fetch('/api/uploads', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        projectId,
        blobUrl: blob.url,
        blobPathname: blob.pathname,
        filename: file.name,
        fileType: file.type,
        fileSize: file.size,
      }),
    });
  }
};
```

Key changes:
- Remove FormData approach
- Add two-step upload: blob first, then metadata
- Keep progress simulation (actual progress would need XHR with onUploadProgress)
- Handle errors from both steps
  </action>
  <verify>Select a 12MB PDF file, click Upload, observe no 413 error, file uploads successfully</verify>
  <done>Client uploads files directly to Blob, then calls API for processing</done>
</task>

<task type="auto">
  <name>Task 3: Update API route to accept blob URL instead of file</name>
  <files>app/api/uploads/route.ts</files>
  <action>
Modify POST handler to accept JSON body with blob URL instead of FormData with file:

New request body:
```typescript
interface UploadRequest {
  projectId: string;
  blobUrl: string;
  blobPathname: string;
  filename: string;
  fileType: string;
  fileSize: number;
}
```

Processing flow:
1. Parse JSON body (not FormData)
2. Validate projectId exists
3. Fetch file content from blobUrl
4. Process document (extraction) using existing DocumentProcessor
5. Create upload record with blobUrl reference

Key changes:
- Change from `formData.get()` to `request.json()`
- Fetch file buffer from blob URL: `const response = await fetch(blobUrl); const buffer = Buffer.from(await response.arrayBuffer());`
- Skip `uploadToStorage()` call (already in Blob)
- Keep all existing document processing logic

Important: Remove the FormData parsing. The file is already in Blob; we just need its URL.
  </action>
  <verify>
1. Upload a small file via UI - succeeds
2. Upload a 12MB PDF via UI - succeeds (was failing with 413)
3. Check database record has blobUrl populated
  </verify>
  <done>API accepts blob URL, fetches content from Blob, processes document, creates DB record</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Small file (<4.5MB) uploads successfully
- [ ] Large file (>4.5MB, test with 12MB PDF) uploads successfully
- [ ] `npm run build` succeeds without errors
- [ ] Upload record in database has correct blobUrl
- [ ] Document extraction works (rawContent populated)
</verification>

<success_criteria>

- All tasks completed
- No 413 errors for files up to 50MB
- Existing functionality preserved (extraction, images, DB records)
- Build passes
</success_criteria>

<output>
After completion, create `.planning/phases/10.1-upload-client-direct/10.1-01-SUMMARY.md`:

# Phase 10.1 Plan 01: Upload Client Direct Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase complete, ready for next phase
</output>
