---
phase: 09-performance-optimization
plan: 02
type: execute
---

<objective>
Add safety infrastructure for concurrent execution: version fields for optimistic concurrency and atomic log appending.

Purpose: Build foundation for safe parallelization without introducing race conditions.
Output: Schema changes + atomic logging pattern ready for future parallelization.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-performance-optimization/DISCOVERY.md
@.planning/phases/09-performance-optimization/09-01-SUMMARY.md

# Source files:
@prisma/schema.prisma
@lib/run-engine/subtask-executor.ts

# Key insight from discovery:
- Current log appending is read-then-write (race condition risk)
- No version fields for optimistic concurrency control
- These need to be in place BEFORE any parallelization
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add version fields to Run models</name>
  <files>prisma/schema.prisma</files>
  <action>
Add version fields to Run, RunEpic, and RunStory models for optimistic concurrency control:

In the Run model, add:
```prisma
version Int @default(1)
```

In the RunEpic model, add:
```prisma
version Int @default(1)
```

In the RunStory model, add:
```prisma
version Int @default(1)
```

These fields will be used for compare-and-swap operations when updating status:
```typescript
// Example future usage:
const updated = await db.run.updateMany({
  where: { id: runId, version: currentVersion },
  data: { status: newStatus, version: { increment: 1 } }
});
if (updated.count === 0) throw new ConcurrencyError();
```
  </action>
  <verify>npx prisma validate passes; npx prisma generate succeeds</verify>
  <done>Version fields added to Run, RunEpic, RunStory models</done>
</task>

<task type="auto">
  <name>Task 2: Create and apply migration</name>
  <files>prisma/migrations/</files>
  <action>
Generate and apply the migration for the new version fields:

```bash
npx prisma migrate dev --name add_version_fields_for_concurrency
```

This creates a migration that:
- Adds `version` column to Run table with default 1
- Adds `version` column to RunEpic table with default 1
- Adds `version` column to RunStory table with default 1

All existing records get version=1 by default.
  </action>
  <verify>npx prisma migrate status shows migrations up to date; npx tsc --noEmit passes</verify>
  <done>Migration created and applied successfully</done>
</task>

<task type="auto">
  <name>Task 3: Create atomic log append utility</name>
  <files>lib/run-engine/log-utils.ts</files>
  <action>
Create a new utility file for atomic log operations that avoids the read-then-write race condition:

```typescript
import { db } from "@/lib/db";

/**
 * Atomically append a log message to a run's logs field.
 * Uses raw SQL to avoid read-then-write race condition.
 */
export async function appendRunLog(
  runId: string,
  message: string
): Promise<void> {
  const timestamp = new Date().toISOString();
  const logEntry = `[${timestamp}] ${message}\n`;

  // Use raw SQL CONCAT to atomically append
  // This avoids the race condition where two processes
  // read the same logs value and one overwrites the other
  await db.$executeRaw`
    UPDATE "Run"
    SET logs = COALESCE(logs, '') || ${logEntry}
    WHERE id = ${runId}
  `;
}

/**
 * Atomically append multiple log messages at once.
 */
export async function appendRunLogs(
  runId: string,
  messages: string[]
): Promise<void> {
  const timestamp = new Date().toISOString();
  const logEntries = messages
    .map(msg => `[${timestamp}] ${msg}`)
    .join('\n') + '\n';

  await db.$executeRaw`
    UPDATE "Run"
    SET logs = COALESCE(logs, '') || ${logEntries}
    WHERE id = ${runId}
  `;
}
```

This utility can be gradually adopted by executors to replace the current pattern.
  </action>
  <verify>npx tsc --noEmit passes; file exists at lib/run-engine/log-utils.ts</verify>
  <done>Atomic log append utility created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] `npx prisma validate` passes
- [ ] Migration applied successfully
- [ ] log-utils.ts exports appendRunLog and appendRunLogs
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Version fields available in Prisma client
- Atomic log utility ready for adoption
- Foundation for safe parallelization in place
</success_criteria>

<output>
After completion, create `.planning/phases/09-performance-optimization/09-02-SUMMARY.md`
</output>
