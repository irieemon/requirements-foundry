---
phase: 07-subtask-generation
plan: 02
type: execute
---

<objective>
Create server actions and executor for subtask generation, following the batch-story pattern.

Purpose: Enable triggering and executing subtask generation with progress tracking.
Output: Working server actions and executor that can generate subtasks from stories.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-subtask-generation/07-01-SUMMARY.md

# Relevant source files (patterns to follow):
@server/actions/batch-stories.ts
@lib/run-engine/batch-story-executor.ts
@lib/run-engine/process-next-trigger.ts

# Key patterns:
- startGenerateAllStories creates Run + RunEpic records, triggers async processing
- executeBatchStoryRun loops through RunEpics, generates stories, updates progress
- getBatchStoryProgress returns current state for frontend polling
- triggerProcessNextAsync uses fire-and-confirm pattern with 10s abort timeout
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create subtask server actions</name>
  <files>server/actions/subtasks.ts</files>
  <action>
Create new server actions file following batch-stories.ts pattern:

```typescript
"use server";

import { revalidatePath } from "next/cache";
import { db } from "@/lib/db";
import { triggerProcessNextAsync } from "@/lib/run-engine/process-next-trigger";

export interface SubtaskGenerationOptions {
  mode: "compact" | "standard" | "detailed";
  existingBehavior: "skip" | "replace";
  pacing: "safe" | "normal" | "fast";
}

export async function startGenerateSubtasks(
  epicId: string,
  storyIds: string[] | null, // null = all stories in epic
  options: SubtaskGenerationOptions
) {
  // 1. Validate epic exists and get stories
  const epic = await db.epic.findUnique({
    where: { id: epicId },
    include: {
      stories: storyIds
        ? { where: { id: { in: storyIds } } }
        : true,
      project: { select: { id: true } },
    },
  });

  if (!epic) {
    return { success: false, error: "Epic not found" };
  }

  if (epic.stories.length === 0) {
    return { success: false, error: "No stories to generate subtasks for" };
  }

  // 2. Check for existing active run
  const activeRun = await db.run.findFirst({
    where: {
      projectId: epic.project.id,
      type: "GENERATE_SUBTASKS",
      status: { in: ["QUEUED", "RUNNING"] },
    },
  });

  if (activeRun) {
    return { success: false, error: "Subtask generation already in progress", runId: activeRun.id };
  }

  // 3. Create run record
  const run = await db.run.create({
    data: {
      projectId: epic.project.id,
      type: "GENERATE_SUBTASKS",
      status: "QUEUED",
      phase: "INITIALIZING",
      totalItems: epic.stories.length,
      options: JSON.stringify(options),
    },
  });

  // 4. Create RunStory junction records
  await db.runStory.createMany({
    data: epic.stories.map((story, index) => ({
      runId: run.id,
      storyId: story.id,
      status: "PENDING",
    })),
  });

  // 5. Trigger async processing
  await triggerProcessNextAsync(run.id);

  revalidatePath(`/projects/${epic.project.id}`);

  return {
    success: true,
    runId: run.id,
    storyCount: epic.stories.length,
  };
}

export async function getSubtaskProgress(runId: string) {
  const run = await db.run.findUnique({
    where: { id: runId },
    include: {
      runStories: {
        include: {
          story: {
            select: { id: true, code: true, title: true },
          },
        },
        orderBy: { createdAt: "asc" },
      },
    },
  });

  if (!run) {
    return null;
  }

  const totalStories = run.runStories.length;
  const completedStories = run.runStories.filter(
    (rs) => rs.status === "COMPLETED" || rs.status === "SKIPPED"
  ).length;
  const failedStories = run.runStories.filter(
    (rs) => rs.status === "FAILED"
  ).length;

  // Calculate estimated remaining time
  const completedWithTime = run.runStories.filter(
    (rs) => rs.status === "COMPLETED" && rs.durationMs
  );
  const avgDuration = completedWithTime.length > 0
    ? completedWithTime.reduce((sum, rs) => sum + (rs.durationMs || 0), 0) / completedWithTime.length
    : 15000; // Default 15s estimate
  const remainingStories = totalStories - completedStories - failedStories;
  const estimatedRemainingMs = remainingStories * avgDuration;

  return {
    runId: run.id,
    status: run.status,
    phase: run.phase,
    phaseDetail: run.phaseDetail,
    totalStories,
    completedStories,
    failedStories,
    skippedStories: run.runStories.filter((rs) => rs.status === "SKIPPED").length,
    totalSubtasks: run.totalCards || 0,
    progress: totalStories > 0 ? Math.round((completedStories / totalStories) * 100) : 0,
    estimatedRemainingMs,
    stories: run.runStories.map((rs) => ({
      id: rs.storyId,
      code: rs.story.code,
      title: rs.story.title,
      status: rs.status,
      subtasksCreated: rs.subtasksCreated,
      durationMs: rs.durationMs,
      errorMsg: rs.errorMsg,
    })),
    startedAt: run.startedAt,
    completedAt: run.completedAt,
    logs: run.logs,
  };
}

export async function cancelSubtaskGeneration(runId: string) {
  const run = await db.run.findUnique({
    where: { id: runId },
  });

  if (!run || run.type !== "GENERATE_SUBTASKS") {
    return { success: false, error: "Run not found" };
  }

  if (run.status !== "RUNNING" && run.status !== "QUEUED") {
    return { success: false, error: "Run is not active" };
  }

  await db.run.update({
    where: { id: runId },
    data: {
      status: "CANCELLED",
      phase: "COMPLETED",
      completedAt: new Date(),
    },
  });

  return { success: true };
}
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Server actions for subtask generation created</done>
</task>

<task type="auto">
  <name>Task 2: Create subtask executor</name>
  <files>lib/run-engine/subtask-executor.ts</files>
  <action>
Create executor following batch-story-executor.ts pattern:

```typescript
import { db } from "@/lib/db";
import { RunLogger } from "./run-logger";
import { AnthropicProvider } from "@/lib/ai/anthropic-provider";
import type { SubtaskGenerationOptions } from "@/server/actions/subtasks";

const PACING_DELAYS = {
  safe: 2000,
  normal: 1000,
  fast: 500,
};

export async function executeSubtaskRun(runId: string) {
  const logger = new RunLogger(runId);

  try {
    // 1. Load run with stories
    const run = await db.run.findUnique({
      where: { id: runId },
      include: {
        runStories: {
          include: {
            story: {
              include: {
                epic: { select: { code: true, title: true } },
              },
            },
          },
          orderBy: { createdAt: "asc" },
        },
      },
    });

    if (!run) {
      throw new Error(`Run ${runId} not found`);
    }

    if (run.status === "CANCELLED") {
      await logger.log("Run was cancelled");
      return;
    }

    const options: SubtaskGenerationOptions = JSON.parse(run.options || "{}");

    // 2. Update to RUNNING
    await db.run.update({
      where: { id: runId },
      data: {
        status: "RUNNING",
        phase: "GENERATING_SUBTASKS",
        startedAt: run.startedAt || new Date(),
        heartbeatAt: new Date(),
      },
    });

    await logger.log(`Starting subtask generation for ${run.runStories.length} stories`);

    const provider = new AnthropicProvider();
    let totalSubtasks = 0;
    let completedCount = 0;
    let failedCount = 0;

    // 3. Process each story
    for (let i = 0; i < run.runStories.length; i++) {
      const runStory = run.runStories[i];

      // Check for cancellation
      const currentRun = await db.run.findUnique({
        where: { id: runId },
        select: { status: true },
      });
      if (currentRun?.status === "CANCELLED") {
        await logger.log("Run cancelled, stopping");
        return;
      }

      // Update progress
      await db.run.update({
        where: { id: runId },
        data: {
          currentItemId: runStory.storyId,
          currentItemIndex: i + 1,
          phaseDetail: `Processing Story ${i + 1} of ${run.runStories.length}: ${runStory.story.code}`,
          heartbeatAt: new Date(),
        },
      });

      // Check existing subtasks
      const existingCount = await db.subtask.count({
        where: { storyId: runStory.storyId },
      });

      if (existingCount > 0 && options.existingBehavior === "skip") {
        await db.runStory.update({
          where: { id: runStory.id },
          data: { status: "SKIPPED" },
        });
        await logger.log(`Skipped ${runStory.story.code} (${existingCount} existing subtasks)`);
        completedCount++;
        continue;
      }

      // Mark as generating
      await db.runStory.update({
        where: { id: runStory.id },
        data: {
          status: "GENERATING",
          startedAt: new Date(),
        },
      });

      const startTime = Date.now();

      try {
        // Delete existing if replacing
        let deletedCount = 0;
        if (existingCount > 0 && options.existingBehavior === "replace") {
          const deleted = await db.subtask.deleteMany({
            where: { storyId: runStory.storyId },
          });
          deletedCount = deleted.count;
          await logger.log(`Deleted ${deletedCount} existing subtasks for ${runStory.story.code}`);
        }

        // Generate subtasks
        const subtasks = await provider.generateSubtasks(
          runStory.story,
          options.mode
        );

        // Save subtasks
        await db.runStory.update({
          where: { id: runStory.id },
          data: { status: "SAVING" },
        });

        await db.subtask.createMany({
          data: subtasks.map((st, idx) => ({
            storyId: runStory.storyId,
            code: `ST${idx + 1}`,
            title: st.title,
            description: st.description,
            effort: st.effort,
            runId: runId,
          })),
        });

        const durationMs = Date.now() - startTime;

        await db.runStory.update({
          where: { id: runStory.id },
          data: {
            status: "COMPLETED",
            subtasksCreated: subtasks.length,
            subtasksDeleted: deletedCount,
            durationMs,
            completedAt: new Date(),
          },
        });

        totalSubtasks += subtasks.length;
        completedCount++;
        await logger.log(`Generated ${subtasks.length} subtasks for ${runStory.story.code} in ${durationMs}ms`);

      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error";
        await db.runStory.update({
          where: { id: runStory.id },
          data: {
            status: "FAILED",
            errorMsg,
            durationMs: Date.now() - startTime,
            completedAt: new Date(),
          },
        });
        failedCount++;
        await logger.log(`Failed ${runStory.story.code}: ${errorMsg}`);
      }

      // Apply pacing delay
      if (i < run.runStories.length - 1) {
        await new Promise((r) => setTimeout(r, PACING_DELAYS[options.pacing] || 1000));
      }
    }

    // 4. Finalize
    const finalStatus = failedCount === run.runStories.length
      ? "FAILED"
      : failedCount > 0
      ? "PARTIAL"
      : "SUCCEEDED";

    await db.run.update({
      where: { id: runId },
      data: {
        status: finalStatus,
        phase: "COMPLETED",
        totalCards: totalSubtasks,
        completedItems: completedCount,
        failedItems: failedCount,
        completedAt: new Date(),
      },
    });

    await logger.log(`Subtask generation complete: ${totalSubtasks} subtasks, ${failedCount} failures`);

  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    await logger.log(`Fatal error: ${errorMsg}`);
    await db.run.update({
      where: { id: runId },
      data: {
        status: "FAILED",
        phase: "FAILED",
        errorMessage: errorMsg,
        completedAt: new Date(),
      },
    });
  }
}
```
  </action>
  <verify>npx tsc --noEmit passes</verify>
  <done>Subtask executor created following batch-story pattern</done>
</task>

<task type="auto">
  <name>Task 3: Integrate executor into process-next route</name>
  <files>app/api/runs/[id]/process-next/route.ts</files>
  <action>
Add GENERATE_SUBTASKS case to the process-next route handler:

1. Import the executor:
```typescript
import { executeSubtaskRun } from "@/lib/run-engine/subtask-executor";
```

2. Add case in the switch statement (find where GENERATE_STORIES is handled):
```typescript
case "GENERATE_SUBTASKS":
  await executeSubtaskRun(run.id);
  break;
```

This enables the fire-and-confirm pattern to work for subtask generation.
  </action>
  <verify>npm run build succeeds</verify>
  <done>Process-next route handles GENERATE_SUBTASKS runs</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx tsc --noEmit` passes
- [ ] `npm run build` succeeds
- [ ] Server actions compile without errors
- [ ] Executor follows batch-story pattern
- [ ] Process-next route integrates subtask executor
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Server actions ready for frontend integration
- Executor can process stories and generate subtasks
</success_criteria>

<output>
After completion, create `.planning/phases/07-subtask-generation/07-02-SUMMARY.md`
</output>
