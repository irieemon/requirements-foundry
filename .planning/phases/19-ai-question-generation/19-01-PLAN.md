---
phase: 19-ai-question-generation
plan: 01
type: execute
---

<objective>
Create the AI clarifying question generator service and extend the data model to store questions and user answers.

Purpose: Enable AI to review uploaded documents + context and generate targeted clarifying questions that help produce better requirements.
Output: AI question generator in lib/ai/, extended UploadContext model with questions/answers fields.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-context-schema-upload-form/18-01-SUMMARY.md

**Codebase context:**
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/INTEGRATIONS.md

**Existing AI patterns:**
@lib/ai/provider.ts
@lib/ai/document-analyzer.ts

**Upload context (from Phase 18):**
@lib/uploads/context-schema.ts
@prisma/schema.prisma

**Established patterns:**
- Anthropic Claude API via @anthropic-ai/sdk
- claude-sonnet-4-20250514 model
- Mock provider fallback for testing without API key
- JSON parsing from AI responses
- Zod schemas for validation

**Constraints from STATE.md:**
- AI questions are one-shot (not interactive chat)
- Context gathering happens during upload flow (not separate step)
- Keep existing shadcn/ui component library
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend UploadContext model for questions and answers</name>
  <files>prisma/schema.prisma, lib/uploads/context-schema.ts</files>
  <action>
Extend UploadContext model in schema.prisma with fields for AI-generated questions and user answers:

```prisma
model UploadContext {
  // ... existing fields ...

  // AI Question Generation
  aiQuestions        String?  @db.Text  // JSON array of generated questions
  aiAnswers          String?  @db.Text  // JSON array of user answers (parallel array)
  questionsGeneratedAt DateTime?         // When AI generated questions
  answersSubmittedAt   DateTime?         // When user submitted answers
}
```

Update lib/uploads/context-schema.ts to add Zod schemas for the question/answer structure:

```typescript
// Question structure from AI
export const aiQuestionSchema = z.object({
  id: z.string(),           // q1, q2, etc.
  question: z.string(),     // The question text
  category: z.enum(["scope", "users", "constraints", "integration", "priority", "other"]),
  importance: z.enum(["high", "medium", "low"]),
  context: z.string().optional(), // Why this question matters
});

export type AIQuestion = z.infer<typeof aiQuestionSchema>;

// Answer structure from user
export const aiAnswerSchema = z.object({
  questionId: z.string(),   // Matches aiQuestionSchema.id
  answer: z.string(),       // User's response
});

export type AIAnswer = z.infer<typeof aiAnswerSchema>;

// For form validation
export const aiAnswersFormSchema = z.object({
  answers: z.array(aiAnswerSchema),
});

export type AIAnswersFormData = z.infer<typeof aiAnswersFormSchema>;
```

Run `npx prisma validate` and `npx prisma generate` after changes.
  </action>
  <verify>
npx prisma validate passes without errors
npx prisma generate succeeds
TypeScript imports AIQuestion, AIAnswer from lib/uploads/context-schema.ts compile
  </verify>
  <done>
Schema valid, types generated
aiQuestions, aiAnswers, questionsGeneratedAt, answersSubmittedAt fields added to UploadContext
Zod schemas for AIQuestion, AIAnswer, AIAnswersFormData exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Create AI clarifying question generator service</name>
  <files>lib/ai/question-generator.ts</files>
  <action>
Create new file lib/ai/question-generator.ts following the existing document-analyzer.ts pattern:

```typescript
// ============================================
// Question Generator - Claude AI Integration
// Generates clarifying questions based on documents + context
// ============================================

import Anthropic from "@anthropic-ai/sdk";
import type { ExtractedContent } from "@/lib/documents/types";
import type { UploadContextFormData } from "@/lib/uploads/context-schema";
import { AIQuestion, aiQuestionSchema } from "@/lib/uploads/context-schema";
import { hasAnthropicKey } from "./provider";
import { z } from "zod";

// Result types
export interface QuestionGenerationResult {
  success: boolean;
  questions?: AIQuestion[];
  error?: string;
  tokensUsed?: number;
}

export interface QuestionGeneratorOptions {
  maxQuestions?: number;  // Default: 5
  focusAreas?: string[];  // Optional focus areas
}

// Interface
export interface QuestionGenerator {
  generateQuestions(
    documentContents: ExtractedContent[],
    userContext: UploadContextFormData | null,
    options?: QuestionGeneratorOptions
  ): Promise<QuestionGenerationResult>;

  isAvailable(): boolean;
}
```

Implement AnthropicQuestionGenerator class:
- Accept document contents (text + images) and user-provided context
- Build prompt that asks Claude to generate 3-7 targeted clarifying questions
- Questions should help understand:
  - Scope boundaries (what's in/out)
  - User needs and priorities
  - Technical constraints
  - Integration requirements
  - Ambiguities in the documents
- Return structured JSON array matching AIQuestion schema
- Parse and validate response with Zod

Implement MockQuestionGenerator class:
- Return deterministic mock questions based on document content
- Useful for testing without API key

Create factory function `getQuestionGenerator()` following getDocumentAnalyzer() pattern.

Prompt should emphasize:
- Questions must be SPECIFIC to the uploaded documents
- Avoid generic questions that could apply to any project
- Each question should reference specific content from the documents
- Questions should help produce better requirements, not be requirements themselves
  </action>
  <verify>
TypeScript compiles without errors
Manual test: Import and call getQuestionGenerator().isAvailable()
  </verify>
  <done>
lib/ai/question-generator.ts exports QuestionGenerator interface, QuestionGenerationResult type
getQuestionGenerator() returns AnthropicQuestionGenerator when API key present, MockQuestionGenerator otherwise
Both implementations return AIQuestion[] matching the Zod schema
  </done>
</task>

<task type="auto">
  <name>Task 3: Create server action for question generation</name>
  <files>server/actions/questions.ts</files>
  <action>
Create new server action file for AI question operations:

```typescript
"use server";

import { db } from "@/lib/db";
import { getQuestionGenerator } from "@/lib/ai/question-generator";
import type { AIQuestion, AIAnswer, AIAnswersFormData } from "@/lib/uploads/context-schema";

// Generate questions for uploads that have context
export async function generateQuestionsForUpload(
  uploadId: string
): Promise<{ success: boolean; questions?: AIQuestion[]; error?: string }> {
  // 1. Fetch upload with context and document content
  // 2. If no context exists, return error (questions require context form to be submitted first)
  // 3. If questions already generated, return existing questions
  // 4. Call questionGenerator.generateQuestions()
  // 5. Store questions JSON in UploadContext.aiQuestions
  // 6. Update questionsGeneratedAt timestamp
  // 7. Return questions
}

// Submit answers for a set of questions
export async function submitQuestionAnswers(
  uploadId: string,
  answersData: AIAnswersFormData
): Promise<{ success: boolean; error?: string }> {
  // 1. Fetch upload context
  // 2. Validate answers match existing questions (by questionId)
  // 3. Store answers JSON in UploadContext.aiAnswers
  // 4. Update answersSubmittedAt timestamp
  // 5. Return success
}

// Get questions and answers for an upload
export async function getQuestionsForUpload(
  uploadId: string
): Promise<{
  questions: AIQuestion[] | null;
  answers: AIAnswer[] | null;
  status: 'no-context' | 'pending-questions' | 'pending-answers' | 'complete';
}> {
  // 1. Fetch upload context
  // 2. Parse questions and answers from JSON
  // 3. Determine status based on what exists
  // 4. Return structured response
}
```

The generateQuestionsForUpload action needs to:
- Load the upload's rawContent (extracted text)
- Load any DocumentImages for multi-modal analysis
- Load the UploadContext form data
- Build ExtractedContent[] from the upload data
- Call the question generator
- Store results
  </action>
  <verify>
TypeScript compiles without errors
Server actions export correctly (can be imported from client components)
  </verify>
  <done>
server/actions/questions.ts exports generateQuestionsForUpload, submitQuestionAnswers, getQuestionsForUpload
All actions properly handle missing data, validation errors
Actions update UploadContext with questions/answers JSON and timestamps
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npx prisma validate` passes
- [ ] `npm run build` succeeds without errors
- [ ] UploadContext has aiQuestions, aiAnswers, questionsGeneratedAt, answersSubmittedAt fields
- [ ] lib/ai/question-generator.ts compiles and exports QuestionGenerator
- [ ] server/actions/questions.ts compiles and exports all three actions
</verification>

<success_criteria>
- UploadContext model extended with question/answer fields
- Zod schemas define AIQuestion and AIAnswer structures
- Question generator service follows existing AI patterns
- Server actions handle generate/submit/get question flows
- No TypeScript errors
- Ready for Plan 02 (UI integration)
</success_criteria>

<output>
After completion, create `.planning/phases/19-ai-question-generation/19-01-SUMMARY.md` using summary template.
</output>
